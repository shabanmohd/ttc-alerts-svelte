<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live TTC Alerts - Route Badge Test</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .route-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.125rem 0.5rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 0.75rem;
            min-width: 2.5rem;
        }
        .route-line-1 { background-color: #FFCC00; color: #000; }
        .route-line-2 { background-color: #00A859; color: #fff; }
        .route-line-3 { background-color: #0072CE; color: #fff; }
        .route-line-4 { background-color: #A020F0; color: #fff; }
        .route-streetcar { background-color: #DA291C; color: #fff; }
        .route-bus { background-color: #0072CE; color: #fff; }
        .route-night { background-color: #1F2937; color: #fff; }
        .route-express { background-color: #059669; color: #fff; }
        .category-SERVICE_DISRUPTION { background-color: #EF4444; color: #fff; }
        .category-SERVICE_RESUMED { background-color: #22C55E; color: #fff; }
        .category-DELAY { background-color: #F59E0B; color: #000; }
        .category-DIVERSION { background-color: #8B5CF6; color: #fff; }
        .category-SHUTTLE { background-color: #06B6D4; color: #000; }
        .category-PLANNED_CLOSURE { background-color: #6B7280; color: #fff; }
        .category-OTHER { background-color: #374151; color: #fff; }
        .loading-spinner {
            border: 3px solid #374151;
            border-top: 3px solid #DA291C;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white p-6">
    <div class="max-w-3xl mx-auto">
        <h1 class="text-2xl font-bold mb-2 text-red-500">ðŸš¨ Live TTC Alerts</h1>
        <p class="text-gray-400 text-sm mb-4">Fetched from Bluesky API with categorization &amp; threading</p>
        
        <div class="bg-gray-800 rounded-lg p-4 mb-6">
            <h3 class="text-sm font-semibold text-gray-400 mb-3">Threading Legend</h3>
            <div class="grid grid-cols-2 gap-4 text-xs">
                <div class="flex items-center gap-2">
                    <div class="w-1 h-6 bg-purple-500 rounded"></div>
                    <div>
                        <span class="text-purple-300 font-medium">ðŸ§µ Bluesky Reply Thread</span>
                        <p class="text-gray-500">TTC posted as reply to original</p>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-1 h-6 bg-orange-500 rounded"></div>
                    <div>
                        <span class="text-orange-300 font-medium">ðŸ”— Semantic Thread</span>
                        <p class="text-gray-500">Matched by route + similarity</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="stats" class="grid grid-cols-3 gap-4 mb-6">
            <div class="bg-gray-800 rounded-lg p-3 text-center">
                <div id="total-count" class="text-2xl font-bold text-blue-400">-</div>
                <div class="text-xs text-gray-500">Total Posts</div>
            </div>
            <div class="bg-gray-800 rounded-lg p-3 text-center">
                <div id="thread-count" class="text-2xl font-bold text-purple-400">-</div>
                <div class="text-xs text-gray-500">Threads</div>
            </div>
            <div class="bg-gray-800 rounded-lg p-3 text-center">
                <div id="route-count" class="text-2xl font-bold text-green-400">-</div>
                <div class="text-xs text-gray-500">Routes Affected</div>
            </div>
        </div>
        
        <div id="loading" class="flex items-center gap-3 justify-center py-8">
            <div class="loading-spinner"></div>
            <span class="text-gray-400">Fetching alerts from Bluesky...</span>
        </div>
        
        <div id="alerts-container" class="space-y-4 hidden"></div>
        
        <details class="mt-8 bg-gray-800 rounded-lg">
            <summary class="cursor-pointer p-4 text-blue-400 font-medium">ðŸ”§ Debug: Raw Data</summary>
            <div class="p-4 pt-0">
                <pre id="raw-data" class="text-xs bg-gray-900 p-3 rounded overflow-x-auto text-gray-300 max-h-96"></pre>
            </div>
        </details>
    </div>

    <script>
        const ALERT_CATEGORIES = {
            SERVICE_DISRUPTION: { keywords: ['no service', 'suspended', 'closed', 'not stopping', 'bypassing'], priority: 1 },
            SERVICE_RESUMED: { keywords: ['regular service', 'resumed', 'restored', 'back to normal', 'now stopping'], priority: 2 },
            DELAY: { keywords: ['delay', 'delayed', 'slower', 'longer wait'], priority: 3 },
            DIVERSION: { keywords: ['diverting', 'detour', 'alternate route', 'diversion'], priority: 4 },
            SHUTTLE: { keywords: ['shuttle', 'buses replacing'], priority: 4 },
            PLANNED_CLOSURE: { keywords: ['planned', 'scheduled', 'maintenance', 'this weekend'], priority: 5 }
        };

        function extractRoutes(text) {
            const routes = [];
            const lineMatch = text.match(/Line\s*(\d+)/gi);
            if (lineMatch) lineMatch.forEach(m => routes.push(m));
            const routeWithSuffixMatch = text.match(/\b(\d{1,3}[A-Z])\b/g);
            if (routeWithSuffixMatch) routeWithSuffixMatch.forEach(m => routes.push(m));
            const routeWithNameMatch = text.match(/\b(\d{1,3})\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/g);
            if (routeWithNameMatch) routeWithNameMatch.forEach(m => routes.push(m));
            const standaloneMatch = text.match(/\b(\d{1,3})(?=[,:\s]|$)/g);
            if (standaloneMatch) standaloneMatch.forEach(num => {
                if (parseInt(num) < 1000 && !routes.some(r => r === num || r.startsWith(num + ' '))) routes.push(num);
            });
            return [...new Set(routes)];
        }

        function categorizeAlert(text) {
            const lowerText = text.toLowerCase();
            for (const [category, config] of Object.entries(ALERT_CATEGORIES)) {
                if (config.keywords.some(kw => lowerText.includes(kw))) return { category, priority: config.priority };
            }
            return { category: 'OTHER', priority: 10 };
        }

        function getDisplayRoutes(affected_routes) {
            const routeFamilies = new Map();
            for (const route of affected_routes) {
                const baseMatch = route.match(/^(\d+)/);
                if (baseMatch) {
                    const base = baseMatch[1];
                    if (!routeFamilies.has(base)) routeFamilies.set(base, []);
                    routeFamilies.get(base).push(route);
                } else if (route.startsWith('Line')) {
                    routeFamilies.set(route, [route]);
                }
            }
            return Array.from(routeFamilies.keys()).map(base => {
                if (base.startsWith('Line')) return base;
                const variants = routeFamilies.get(base);
                if (variants.length === 1 && /^\d+[A-Z]$/.test(variants[0])) return variants[0];
                return base;
            });
        }

        function getRouteBadgeClass(route) {
            if (route.startsWith('Line 1')) return 'route-line-1';
            if (route.startsWith('Line 2')) return 'route-line-2';
            if (route.startsWith('Line 3')) return 'route-line-3';
            if (route.startsWith('Line 4')) return 'route-line-4';
            const numMatch = route.match(/^(\d+)/);
            if (numMatch) {
                const num = parseInt(numMatch[1]);
                if (num >= 500 && num <= 514) return 'route-streetcar';
                if (num >= 300 && num <= 399) return 'route-night';
                if (num >= 900) return 'route-express';
            }
            return 'route-bus';
        }

        function jaccardSimilarity(text1, text2) {
            const words1 = new Set(text1.toLowerCase().split(/\s+/).filter(w => w.length > 2));
            const words2 = new Set(text2.toLowerCase().split(/\s+/).filter(w => w.length > 2));
            const intersection = new Set([...words1].filter(x => words2.has(x)));
            const union = new Set([...words1, ...words2]);
            return intersection.size / union.size;
        }

        function extractRouteNumber(route) {
            const match = route.match(/^(\d+)/);
            return match ? match[1] : route;
        }

        function routesMatch(route1, route2) {
            // Compare base route numbers (37A matches 37, 37B, etc.)
            return extractRouteNumber(route1) === extractRouteNumber(route2);
        }
        
        // Extract location keywords (intersections, stations, streets)
        function extractLocation(text) {
            const lowerText = text.toLowerCase();
            const locations = [];
            
            // Match intersection patterns: "X at Y", "X and Y"
            const atMatch = text.match(/at\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*(?:\s+(?:Ave|St|Blvd|Rd|Dr|Cres|Way|Pkwy|Ln))?)/gi);
            if (atMatch) locations.push(...atMatch.map(m => m.toLowerCase()));
            
            // Match "due to" locations (collision at X)
            const dueToMatch = text.match(/due to\s+(?:a\s+)?(\w+)/gi);
            if (dueToMatch) locations.push(...dueToMatch.map(m => m.toLowerCase()));
            
            // Extract street names
            const streetMatch = text.match(/\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?\s+(?:Ave|St|Blvd|Rd|Dr|Way))\b/gi);
            if (streetMatch) locations.push(...streetMatch.map(m => m.toLowerCase()));
            
            return [...new Set(locations)];
        }
        
        // Enhanced similarity for TTC alerts
        function alertSimilarity(text1, text2) {
            // Base Jaccard similarity
            const jaccard = jaccardSimilarity(text1, text2);
            
            // Location overlap bonus
            const loc1 = extractLocation(text1);
            const loc2 = extractLocation(text2);
            const locOverlap = loc1.filter(l => loc2.some(l2 => l.includes(l2) || l2.includes(l))).length;
            const locationBonus = locOverlap > 0 ? 0.15 : 0;
            
            // Same cause bonus (collision, medical emergency, etc.)
            const causes = ['collision', 'medical emergency', 'fire', 'police', 'construction', 'stalled', 'track work'];
            const cause1 = causes.find(c => text1.toLowerCase().includes(c));
            const cause2 = causes.find(c => text2.toLowerCase().includes(c));
            const causeBonus = (cause1 && cause1 === cause2) ? 0.1 : 0;
            
            return Math.min(1, jaccard + locationBonus + causeBonus);
        }

        function buildThreads(posts) {
            const threads = new Map();
            const semanticMatches = new Map();
            
            // Pass 1: Group by Bluesky reply structure
            posts.forEach(item => {
                const post = item.post;
                const reply = item.reply;
                if (reply && reply.root) {
                    const rootUri = reply.root.uri;
                    if (!threads.has(rootUri)) threads.set(rootUri, []);
                    threads.get(rootUri).push(item);
                } else {
                    threads.set(post.uri, [item]);
                }
            });
            
            // Pass 2: Semantic threading with enhanced matching
            const rootPosts = posts.filter(item => !item.reply || !item.reply.root);
            rootPosts.sort((a, b) => new Date(a.post.record.createdAt) - new Date(b.post.record.createdAt));
            
            for (let i = 1; i < rootPosts.length; i++) {
                const currentItem = rootPosts[i];
                const currentUri = currentItem.post.uri;
                const currentText = currentItem.post.record.text;
                const currentRoutes = extractRoutes(currentText);
                const currentCategory = categorizeAlert(currentText).category;
                const currentTime = new Date(currentItem.post.record.createdAt);
                const currentBaseRoutes = currentRoutes.map(extractRouteNumber);
                
                if (semanticMatches.has(currentUri) || currentRoutes.length === 0) continue;
                
                let bestMatch = null;
                let bestScore = 0;
                
                for (let j = i - 1; j >= 0; j--) {
                    const earlierItem = rootPosts[j];
                    const earlierUri = earlierItem.post.uri;
                    const earlierText = earlierItem.post.record.text;
                    const earlierRoutes = extractRoutes(earlierText);
                    const earlierTime = new Date(earlierItem.post.record.createdAt);
                    const earlierBaseRoutes = earlierRoutes.map(extractRouteNumber);
                    
                    const hoursDiff = (currentTime - earlierTime) / (1000 * 60 * 60);
                    if (hoursDiff > 6 || earlierRoutes.length === 0) continue;
                    
                    // Check if any base route matches (37 variants all match)
                    const hasRouteOverlap = currentBaseRoutes.some(br => earlierBaseRoutes.includes(br));
                    if (!hasRouteOverlap) continue;
                    
                    // Use enhanced similarity
                    const similarity = alertSimilarity(currentText, earlierText);
                    
                    // Determine threshold based on category
                    let threshold = 0.5;
                    if (currentCategory === 'SERVICE_RESUMED') threshold = 0.1;
                    else if (currentCategory === 'DIVERSION' || currentCategory === 'DELAY') threshold = 0.25;
                    
                    if (similarity >= threshold && similarity > bestScore) {
                        bestMatch = { earlierUri, earlierItem, similarity };
                        bestScore = similarity;
                    }
                }
                
                if (bestMatch) {
                    currentItem._semanticThread = true;
                    currentItem._similarity = (bestMatch.similarity * 100).toFixed(1);
                    
                    let rootUri = bestMatch.earlierUri;
                    while (semanticMatches.has(rootUri)) rootUri = semanticMatches.get(rootUri);
                    
                    if (threads.has(rootUri)) {
                        threads.get(rootUri).push(currentItem);
                        threads.delete(currentUri);
                        semanticMatches.set(currentUri, rootUri);
                    }
                }
            }
            return threads;
        }

        function renderAlertCard(item, threadReplies) {
            const post = item.post;
            const text = post.record.text;
            const category = categorizeAlert(text).category;
            const routes = extractRoutes(text);
            const displayRoutes = getDisplayRoutes(routes);
            const createdAt = new Date(post.record.createdAt).toLocaleString();
            
            const badges = displayRoutes.map(r => '<span class="route-badge ' + getRouteBadgeClass(r) + '">' + r + '</span>').join('');
            const hasSemanticThreading = threadReplies.some(r => r._semanticThread);
            
            let repliesHtml = '';
            if (threadReplies.length > 0) {
                repliesHtml = '<div class="mt-3 border-l-2 border-gray-600 pl-3 space-y-2">' + 
                    threadReplies.map(reply => {
                        const rt = reply.post.record.text;
                        const rc = categorizeAlert(rt).category;
                        const rtm = new Date(reply.post.record.createdAt).toLocaleString();
                        const semBadge = reply._semanticThread ? '<span class="text-xs px-2 py-0.5 rounded bg-orange-900 text-orange-300 ml-2">ðŸ”— ' + reply._similarity + '% match</span>' : '';
                        return '<div class="text-sm"><span class="text-xs px-2 py-0.5 rounded category-' + rc + '">' + rc.replace('_', ' ') + '</span>' + semBadge + '<span class="text-gray-500 text-xs ml-2">' + rtm + '</span><p class="text-gray-300 mt-1">' + rt + '</p></div>';
                    }).join('') + '</div>';
            }
            
            const borderClass = threadReplies.length > 0 ? (hasSemanticThreading ? 'border-l-4 border-orange-500' : 'border-l-4 border-purple-500') : '';
            const threadBadge = threadReplies.length > 0 ? '<span class="text-xs px-2 py-0.5 rounded ' + (hasSemanticThreading ? 'bg-orange-900 text-orange-300' : 'bg-purple-900 text-purple-300') + '">' + (hasSemanticThreading ? 'ðŸ”—' : 'ðŸ§µ') + ' ' + (threadReplies.length + 1) + ' posts</span>' : '';
            
            return '<div class="bg-gray-800 rounded-lg p-4 ' + borderClass + '">' +
                '<div class="flex items-center gap-2 mb-2 flex-wrap">' + (badges || '<span class="text-gray-500 text-xs">No routes</span>') +
                '<span class="text-xs px-2 py-0.5 rounded category-' + category + '">' + category.replace('_', ' ') + '</span>' + threadBadge + '</div>' +
                '<p class="text-sm text-gray-300">' + text + '</p>' +
                '<div class="mt-2 flex justify-between items-start"><div class="text-xs text-gray-500">' +
                '<div>ðŸ“ affected_routes: [' + routes.map(r => '"' + r + '"').join(', ') + ']</div>' +
                '<div>ðŸ·ï¸ display_routes: [' + displayRoutes.map(r => '"' + r + '"').join(', ') + ']</div></div>' +
                '<span class="text-xs text-gray-600">' + createdAt + '</span></div>' + repliesHtml + '</div>';
        }

        function getHistoricalAlerts() {
            const now = new Date();
            const ago = (hours) => new Date(now.getTime() - hours * 60 * 60 * 1000).toISOString();
            return [
                // Bluesky Reply Thread: Line 4
                { post: { uri: 'at://h/line4-root', record: { text: 'Line 4 Sheppard: No service between Sheppard-Yonge and Don Mills stations due to a fire investigation.', createdAt: ago(5) } } },
                { post: { uri: 'at://h/line4-shuttle', record: { text: 'Line 4 Sheppard: Shuttle buses now available between Sheppard-Yonge and Don Mills stations.', createdAt: ago(4) } }, reply: { root: { uri: 'at://h/line4-root' } } },
                { post: { uri: 'at://h/line4-resumed', record: { text: 'Line 4 Sheppard: Regular service has resumed between Sheppard-Yonge and Don Mills stations.', createdAt: ago(3) } }, reply: { root: { uri: 'at://h/line4-root' } } },
                
                // Semantic Thread: 504 King (separate posts - NOT replies)
                { post: { uri: 'at://h/504-detour', record: { text: '504 King: Detour westbound via Church St, Wellington St E and York St while we respond to a medical emergency.', createdAt: ago(6.5) } } },
                { post: { uri: 'at://h/504-resumed', record: { text: '504 King: Regular service has resumed westbound near King St East at Church St West Side.', createdAt: ago(6) } } },
                
                // Semantic Thread: 37/37A/37B (separate posts)
                { post: { uri: 'at://h/37-collision', record: { text: '37, 37A, 37B Islington: Detour via Bloor St West and Islington Ave due to a collision.', createdAt: ago(8) } } },
                { post: { uri: 'at://h/37-resumed', record: { text: '37, 37A, 37B Islington: Regular service has resumed. All routes now operating on regular routing.', createdAt: ago(6) } } },
                
                // Semantic Thread: 939 Express
                { post: { uri: 'at://h/939-diversion', record: { text: '939 Finch Express: Diverting via Finch Ave West and Keele St due to a road closure.', createdAt: ago(5) } } },
                { post: { uri: 'at://h/939-resumed', record: { text: '939 Finch Express: Regular service has resumed on regular routing.', createdAt: ago(4) } } },
                
                // Semantic Thread: 85 Sheppard
                { post: { uri: 'at://h/85-bypass', record: { text: '85 Sheppard East: Bypassing stops on Sheppard Ave East between Victoria Park Ave and Warden Ave.', createdAt: ago(7) } } },
                { post: { uri: 'at://h/85-resumed', record: { text: '85 Sheppard East: Now stopping at all regular stops on Sheppard Ave East.', createdAt: ago(5.5) } } },
                
                // Standalone posts
                { post: { uri: 'at://h/320-delay', record: { text: '320 Yonge: Delays northbound at Yonge St and Eglinton Ave due to construction.', createdAt: ago(10) } } },
                { post: { uri: 'at://h/37b-delay', record: { text: '37B Islington: Minor delays westbound near Islington Station.', createdAt: ago(20) } } },
                
                // Bluesky Reply Thread: Line 2 Planned
                { post: { uri: 'at://h/l2-planned', record: { text: 'Line 2 Bloor-Danforth: Planned closure this weekend between St George and Broadview stations for track maintenance.', createdAt: ago(48) } } },
                { post: { uri: 'at://h/l2-reminder', record: { text: 'Line 2 Bloor-Danforth: Reminder - No subway service today for scheduled maintenance. Use shuttle buses.', createdAt: ago(24) } }, reply: { root: { uri: 'at://h/l2-planned' } } }
            ];
        }

        async function fetchAndRender() {
            const loadingEl = document.getElementById('loading');
            const containerEl = document.getElementById('alerts-container');
            const rawDataEl = document.getElementById('raw-data');
            
            try {
                const response = await fetch('https://public.api.bsky.app/xrpc/app.bsky.feed.getAuthorFeed?actor=ttcalerts.bsky.social&limit=30');
                const data = await response.json();
                const livePosts = data.feed || [];
                const historicalPosts = getHistoricalAlerts();
                const allPosts = [...livePosts, ...historicalPosts];
                
                rawDataEl.textContent = JSON.stringify({ live: data, historical: historicalPosts }, null, 2);
                
                const threads = buildThreads(allPosts);
                const allRoutes = new Set();
                allPosts.forEach(item => {
                    extractRoutes(item.post.record.text).forEach(r => allRoutes.add(extractRouteNumber(r)));
                });
                
                document.getElementById('total-count').textContent = allPosts.length;
                document.getElementById('thread-count').textContent = threads.size;
                document.getElementById('route-count').textContent = allRoutes.size;
                
                // Render live alerts
                let liveHtml = '<h2 class="text-lg font-bold text-green-400 mb-4">ðŸ”´ Live Alerts</h2>';
                livePosts.forEach(item => {
                    if (!item.reply || !item.reply.root) {
                        const threadReplies = [];
                        livePosts.forEach(other => {
                            if (other.reply && other.reply.root && other.reply.root.uri === item.post.uri) threadReplies.push(other);
                        });
                        // Also check semantic matches
                        threads.forEach((posts, uri) => {
                            if (uri === item.post.uri && posts.length > 1) {
                                posts.slice(1).forEach(p => { if (!threadReplies.includes(p)) threadReplies.push(p); });
                            }
                        });
                        threadReplies.sort((a, b) => new Date(a.post.record.createdAt) - new Date(b.post.record.createdAt));
                        liveHtml += renderAlertCard(item, threadReplies);
                    }
                });
                
                // Render historical alerts  
                let histHtml = '<h2 class="text-lg font-bold text-purple-400 mb-4 mt-8">ðŸ“œ Historical Test Alerts</h2>';
                const histThreads = buildThreads(historicalPosts);
                histThreads.forEach((posts, uri) => {
                    const rootPost = posts[0];
                    const replies = posts.slice(1);
                    replies.sort((a, b) => new Date(a.post.record.createdAt) - new Date(b.post.record.createdAt));
                    histHtml += renderAlertCard(rootPost, replies);
                });
                
                loadingEl.classList.add('hidden');
                containerEl.classList.remove('hidden');
                containerEl.innerHTML = liveHtml + histHtml;
            } catch (error) {
                loadingEl.innerHTML = '<span class="text-red-500">Error: ' + error.message + '</span>';
            }
        }
        
        fetchAndRender();
    </script>
</body>
</html>
